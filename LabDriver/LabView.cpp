// -*- C++ -*-
//
// generated by wxGlade 0.7.2 on Thu Oct 20 13:35:21 2016
//
// Example for compiling a single file project under Linux using g++:
//  g++ MyApp.cpp $(wx-config --libs) $(wx-config --cxxflags) -o MyApp
//
// Example for compiling a multi file project under Linux using g++:
//  g++ main.cpp $(wx-config --libs) $(wx-config --cxxflags) -o MyApp Dialog1.cpp Frame1.cpp
//

#include "LabView.h"

std::atomic<bool> control = true;

// begin wxGlade: ::extracode
// end wxGlade


//const float STEPPERMM = STEPPERTURN/25.4; //TODO change this to be se from within the header dialog



MotorController* mot;
//VoltageNI* voltNI;
//VoltageControl* volt;
Voltage* volt;
Panel* panelConfig;
HeaderEdit* HeaderWindow;
Messages* message;
WeinerCounter* nim;
HeaderInfoGen globalHeader;
HeaderInfoGen* pglobalheader;
VoltageFactory* vf;
Readout* readout;
readoutedit* readoutframe;
//Histogram* Image;

static bool connected = false;
Offset offsets[4];

BigFrame::BigFrame(wxWindow* parent) : MainFrame(parent){
	message = new Messages();
	pglobalheader = &globalHeader;
	vf = new VoltageFactory();
	readout = new Readout();

  stop->Disable();
  m_button23->Disable();
  m_button18->Disable();
  setScanType();
}

void BigFrame::onQuit(wxCommandEvent& WXUNUSED(event))
{
	if (volt){
		volt->turnOff();
		volt->end();
	}
	delete volt;
	delete nim;
	delete mot;
	delete vf;
	delete message;
	delete readout;
	Close(true);
}

void BigFrame::yUpButtonClicked(wxCommandEvent & event){
	try{
		mot->stepMotor(2, distanceToMoveY);
	}
	catch (...){ }
}

void BigFrame::yDownButtonClicked(wxCommandEvent & event)
{
	//distanceToMove = distanceBox->GetSelection();
	mot->stepMotor(2, -distanceToMoveY);

}

void BigFrame::xLeftButtonClicked(wxCommandEvent & event)
{
	//distanceToMove = distanceBox->GetSelection();
	mot->stepMotor(1, distanceToMoveX);

}

void BigFrame::xRightButtonClicked(wxCommandEvent & event)
{
	//distanceToMove = distanceBox->GetSelection();
	mot->stepMotor(1, -distanceToMoveX);

}

void BigFrame::setHome(wxCommandEvent& event)
{
	mot->setZero();
}

void BigFrame::goToHome(wxCommandEvent& event)
{
	int selection = m_radioBox4->GetSelection();
	if (selection == 0)
		mot->goZero();
	else
	{
		mot->goZero();
		mot->goTo(offsets[selection].stepsX, offsets[selection].stepsY);
	}
}

void BigFrame::markButtonClicked(wxCommandEvent & event)
{
	int selection = m_radioBox4->GetSelection();

	if (selection != 0)
	{
		offsets[selection].stepsX = mot->getAbsolutePositionX();
		offsets[selection].stepsY = mot->getAbsolutePositionY();
	}
}

void BigFrame::distanceBoxClicked(wxCommandEvent & event)
{
	distanceToMoveX = convertDistance(distanceBox->GetSelection(), 1);
	distanceToMoveY = convertDistance(distanceBox->GetSelection(), 2);
}


//
int BigFrame::convertDistance(int radioButton, int motor){
	int ret;
	int stepsmm = 400;
	if (motor == 1)
		stepsmm = wxAtoi(m_textCtrl41->GetLineText(0));
	if (motor == 2)
		stepsmm = wxAtoi(m_textCtrl29->GetLineText(0));
	switch (radioButton){
	case 0:
		ret = (int)(0.1 * stepsmm);
		break;
	case 1:
		ret = (int)(1.0 * stepsmm);
		break;
	case 2:
		ret = (int)(5.0 * stepsmm);
		break;
	case 3:
		ret = (int)(10.0 * stepsmm);
		break;
	case 4:
		ret = (int)(stepsmm * wxAtof(m_textCtrl28->GetLineText(0)));
		break;
	default:
		ret = 0;
		break;
	}

	return ret;
}

void BigFrame::scanTypeSelected(wxCommandEvent & event){
  setScanType();
}

void BigFrame::setScanType(){
  //probably want to make these field disabling things into functions calls
  switch (m_choice1->GetSelection()){
	case 0:
    scanTypeFree();
	break;
	case 1:
    scanTypeLine();
    break;
	case 2:
    scanTypeHex();
    break;
	case 3:
    scanTypeXY();
    break;
	default:
		scanTypeFree();
		break;
  }
}

//wxStaticBoxSizer* test;

void BigFrame::toggleHV(wxCommandEvent& event){
	int voltageStatus = m_radioBox3->GetSelection();
	if (voltageStatus == 0){
		string voltage = m_textCtrl22->GetLineText(0);
    volt->setVoltage(stoi(voltage));
		volt->turnOn();
	}
	if (voltageStatus == 1)
		volt->turnOff();
}

void BigFrame::setStartVoltage(wxCommandEvent& event){
	//string voltage = m_textCtrl22->GetLineText(0);
	
}

void BigFrame::motorControllerConnectClicked(wxCommandEvent & event){
	//static bool connected = false;
	static int portnum;

	if (!connected){
		portnum = wxAtoi(m_choice2->GetStringSelection());
		mot = new MotorController(portnum, 9600);
		connected = true;
		m_button15->Disable();
		m_button16->Enable();
	}
}

void BigFrame::motorControllerDisconnectClicked(wxCommandEvent & event){
	mot->portClose();
	mot = nullptr;
	m_button15->Enable();
	m_button16->Disable();
	delete mot;
	connected = false;
}

void BigFrame::HVConnectClicked(wxCommandEvent & event){
	string hv = hvChoice->GetStringSelection();
  volt = vf->newVolt(hv);
	volt->init(5);
	volt->turnOff();
	hvChoice->Disable();
	m_button17->Disable();
	m_button18->Enable();
}

void BigFrame::HVDisconnectClicked(wxCommandEvent& event){
  delete volt;
	volt = nullptr;
	hvChoice->Enable();
	m_button17->Enable();
	m_button18->Disable();
}

void BigFrame::openPanelFrame(wxCommandEvent& event) 
{ 
	if (panelConfig == nullptr)
		panelConfig = new Panel(this);
	panelConfig->Show(true);
}

void BigFrame::setEndVoltage(wxCommandEvent & event)
{
	//m_textCtrl23->SelectAll();
	//if (wxAtoi(m_textCtrl22->GetLineText(0)) >= wxAtoi(m_textCtrl23->GetLineText(0)))
	//{
	//	m_textCtrl23->WriteText(m_textCtrl22->GetLineText(0));
	//}
}

void BigFrame::updateButtonClicked(wxCommandEvent& event){
	int startvoltage, endvoltage, xoffset, yoffset, xstepsize, ystepsize, voltagestepsize, dwelltime;
	int numsteps, frequency;
	int motorstepx, motorstepy;

	double xoffsetmm, yoffsetmm, xstepsizemm, ystepsizemm;
	double totaltime;

	startvoltage = wxAtoi(m_textCtrl22->GetLineText(0));
	endvoltage = wxAtoi(m_textCtrl23->GetLineText(0));
	voltagestepsize = wxAtoi(m_textCtrl40->GetLineText(0));
  xoffsetmm = wxAtof(m_textCtrl18->GetLineText(0));
  yoffsetmm = wxAtof(m_textCtrl19->GetLineText(0));
  xstepsizemm = wxAtof(m_textCtrl20->GetLineText(0));
  ystepsizemm = wxAtof(m_textCtrl21->GetLineText(0));
  motorstepx = wxAtoi(m_textCtrl41->GetLineText(0));
  motorstepy = wxAtoi(m_textCtrl29->GetLineText(0));
  dwelltime = wxAtoi(m_textCtrl42->GetLineText(0));
  frequency = wxAtoi(m_textCtrl43->GetLineText(0));

  numsteps = 0;
  if (startvoltage < endvoltage)
  {
    for (double i = startvoltage; i <= endvoltage; i += voltagestepsize){
      ++numsteps;
    }
  }
  else if (startvoltage == endvoltage)
  {
    numsteps = 0;
  }
  else if (startvoltage > endvoltage)
  {
    wxMessageBox(wxT("Starting voltage larger than ending voltage! Ending voltage set equal to starting voltage."));
    endvoltage = startvoltage;
    m_textCtrl23->SelectAll();
    m_textCtrl23->WriteText(wxString::Format(wxT("%i"), endvoltage));
  }

  if (scanType == "Free")
  { 
	  numsteps = 1;
	  endvoltage = startvoltage;
	  m_textCtrl23->SetValue(wxString::Format(wxT("%i"), endvoltage));
  }
	
  if (scanType == "Hex_Scan_X" || scanType == "XY_Scan" || scanType == "Line_Scan" || scanType == "Hex_Scan_Y"){
    if (xstepsizemm == 0){
      wxMessageBox("Invalid x-step yize. Defaulting to 0.1 mm");
      xstepsizemm = 0.1;
      m_textCtrl20->SelectAll();
      m_textCtrl20->WriteText(wxString::Format(wxT("%f"), xstepsizemm));
      
    }
    if (ystepsizemm == 0){
      wxMessageBox("Invalid y-step size. Defaulting to 0.1 mm");
      ystepsizemm = 0.1;
      m_textCtrl21->SelectAll();
      m_textCtrl21->WriteText(wxString::Format(wxT("%f"), ystepsizemm));
    }
    if (motorstepx == 0){
      wxMessageBox("Invalid x steps/mm. Defaulting to 398 steps/mm");
      motorstepx = 398;
      m_textCtrl41->SelectAll();
      m_textCtrl41->WriteText(wxString::Format(wxT("%i"), motorstepx));

    }
    if (motorstepy == 0){
      wxMessageBox("Invalid y steps/mm. Defaulting to 400 steps/mm");
      motorstepy = 400;
      m_textCtrl29->SelectAll();
      m_textCtrl29->WriteText(wxString::Format(wxT("%i"), motorstepy));
    }

		xoffset = motorstepx * xoffsetmm;
		xstepsize = motorstepx * xstepsizemm;

		yoffset = motorstepy * yoffsetmm;
		ystepsize = motorstepy * ystepsizemm;
		totaltime = xoffset / xstepsize * yoffset / ystepsize * numsteps * dwelltime;
    message->totalOffsetX = xoffset;
    message->stepX = xstepsize;
    message->stepY = ystepsize;
    message->totalOffsetY = yoffset;
	}
	else if(scanType == "Voltage_Scan"){
    totaltime = numsteps * dwelltime;
	}
  else{
    totaltime = -1;
  }
	

  m_textCtrl45->SelectAll();
  m_textCtrl45->WriteText(wxString::Format(wxT("%i"), numsteps));

	m_textCtrl46->SelectAll();
	m_textCtrl46->WriteText(wxString::Format(wxT("%f"), totaltime / 3600));

	

	message->frequency = frequency;
	
	//message->numPix = 1;
	message->time = dwelltime;
	message->voltageStart = startvoltage;
	message->voltageEnd = endvoltage;
	message->voltageStep = voltagestepsize;
	message->runtype = scanType;

}

HeaderEdit::HeaderEdit(wxWindow* parent) : header(parent){}

void BigFrame::openHeaderFrame(wxCommandEvent& event){
  if (!HeaderWindow || HeaderWindow == nullptr){
    HeaderWindow = new HeaderEdit(this);
  }
	HeaderWindow->Show(true);
}

string HeaderEdit::getSourceConfig(){
	switch (m_radioBox1->GetSelection()){
	case 0:
		return string("Dynamic");
		break;
	case 1:
		return string("Static");
		break;
	case 2:
		return string("User");
		break;
	default:
		return string("Not Selected");
		break;
	}
}

void HeaderEdit::setSourceConfig(string type){
	if (type.compare("Dynamic")){
		m_radioBox1->SetSelection(0);
	}
	else if (type.compare("Static")){
		m_radioBox1->SetSelection(1);
	}
	else if (type.compare("User")){
		m_radioBox1->SetSelection(2);
	}
  else{
    wxMessageBox(wxT("No Source Type Found!"));
  }
}

void HeaderEdit::headerOkClicked(wxCommandEvent& event){
	copyData(globalHeader);
	Show(false);
	//HeaderWindow->Destroy();
	//HeaderWindow = nullptr;
}
void HeaderEdit::headerCancelClicked(wxCommandEvent& event){
	Show(false);
}

void HeaderEdit::saveHeader(wxCommandEvent& event){
	copyData(globalHeader);
	string fullpath;
	wxFileDialog* SaveDialog = new wxFileDialog(
		this, _("Choose a location to save to"), wxEmptyString, wxString(pglobalheader->panelName), wxT("Text File (*.txt) | *.txt"),
		wxFD_SAVE | wxFD_OVERWRITE_PROMPT);

	//if (SaveDialog->ShowModal() == wxID_CANCEL)
	//	SaveDialog->Destroy();     // the user changed idea...

  // if the user click "Save" instead of "Cancel"
	if (SaveDialog->ShowModal() == wxID_OK){

		fullpath = SaveDialog->GetFilename();
		//wxMessageBox(fullpath);

		ofstream file;
		file.open(fullpath);

		file << globalHeader;
		file.close();
		//makeGenHeadFile(headerInfo, fullpath);
	}
	else
		SaveDialog->Destroy();
}

void HeaderEdit::openHeader(wxCommandEvent& event){
	string fullpath;
	wxFileDialog* OpenDialog = new wxFileDialog(
		this, _("Choose header file to open"), wxT("Text File (*.txt) | *.txt"));
  // if the user click "Save" instead of "Cancel"
	if (OpenDialog->ShowModal() == wxID_OK){

		fullpath = OpenDialog->GetPath();
		//wxMessageBox(fullpath);

		makeGenHeadFile(globalHeader, fullpath);
		putData(globalHeader);
	}
	else
		OpenDialog->Destroy();
}

void HeaderEdit::updateGas(wxCommandEvent& event){
	updateGas();
}

void HeaderEdit::updateGas()
{
	wxString gasMix;
	int gasTotal = 0;

	vector<wxString> gasTypes;
	vector<wxString> gasPercent;

	gasTypes.push_back(m_comboBox3->GetStringSelection());
	gasTypes.push_back(m_comboBox2->GetStringSelection());
	gasTypes.push_back(m_comboBox1->GetStringSelection());

	gasPercent.push_back(m_textCtrl51->GetLineText(0));
	gasPercent.push_back(m_textCtrl50->GetLineText(0));
	gasPercent.push_back(m_textCtrl49->GetLineText(0));

	while (!gasTypes.empty()){
		gasMix += gasPercent.back() + "_";
		gasTotal += wxAtoi(gasPercent.back());
		gasMix += gasTypes.back() + "-";
		gasPercent.pop_back();
		gasTypes.pop_back();
	}

	m_textCtrl13->SelectAll();
	m_textCtrl13->WriteText(gasMix);

	m_textCtrl52->SelectAll();
	m_textCtrl52->WriteText(wxString::Format(wxT("%i", gasTotal)));
}

void HeaderEdit::copyData(HeaderInfoGen &headerInfo){
	headerInfo.panelName = m_textCtrl1->GetLineText(0);
	headerInfo.sourceName = m_textCtrl11->GetLineText(0);
	headerInfo.sourceConfig = getSourceConfig();
  headerInfo.sourceHeight = wxAtof(m_textCtrl30->GetLineText(0));
  headerInfo.collimatorSize = wxAtof(m_textCtrl29->GetLineText(0));
	//headerInfo.triggerSetup = m_textCtrl38->GetLineText(0);
	headerInfo.gas = m_textCtrl13->GetLineText(0);
	headerInfo.pressure = wxAtof(m_textCtrl131->GetLineText(0));
	headerInfo.discThresh = wxAtof(m_textCtrl48->GetLineText(0));
	headerInfo.quench = wxAtof(m_textCtrl132->GetLineText(0));
	//headerInfo.numRO = wxAtoi(m_textCtrl35->GetLineText(0));
	//headerInfo.roLines = m_textCtrl341->GetLineText(0);
	//headerInfo.triggerRO = m_textCtrl38->GetLineText(0);
	headerInfo.attenRO = wxAtof(m_textCtrl24->GetLineText(0));
	headerInfo.numHV = wxAtoi(m_textCtrl1324->GetLineText(0));
	headerInfo.linesHV = m_textCtrl1325->GetLineText(0);
	//headerInfo.triggerHV = m_textCtrl37->GetLineText(0);
	//headerInfo.attenHV = wxAtof(m_textCtrl36->GetLineText(0));
	headerInfo.runStartTime = 0;

}

void HeaderEdit::putData(HeaderInfoGen &headerInfo){
		m_textCtrl1->Clear();
		m_textCtrl1->WriteText(headerInfo.panelName);
		m_textCtrl11->Clear();
		m_textCtrl11->WriteText(headerInfo.sourceName);
	  m_textCtrl30->WriteText(wxString::Format(wxT("%f"), headerInfo.sourceHeight));
	  m_textCtrl29->WriteText(wxString::Format(wxT("%f"), headerInfo.collimatorSize));
		//m_textCtrl1322->WriteText(headerInfo.triggerSetup);
		m_textCtrl13->Clear();
		m_textCtrl13->WriteText(headerInfo.gas);
		m_textCtrl131->Clear();
		m_textCtrl131->WriteText(wxString::Format(wxT("%f"), headerInfo.pressure));
		m_textCtrl48->Clear();
		m_textCtrl48->WriteText(wxString::Format(wxT("%f"), headerInfo.discThresh));
		m_textCtrl132->Clear();
		m_textCtrl132->WriteText(wxString::Format(wxT("%f"), headerInfo.quench));
		//m_textCtrl35->Clear();
		//m_textCtrl35->WriteText(wxString::Format(wxT("%i"), headerInfo.numRO));
		//m_textCtrl341->Clear();
		//m_textCtrl341->WriteText(headerInfo.roLines);
		//m_textCtrl12->WriteText(headerInfo.triggerRO);
		m_textCtrl24->Clear();
		m_textCtrl24->WriteText(wxString::Format(wxT("%f"), headerInfo.attenRO));
		m_textCtrl1324->Clear();
		m_textCtrl1324->WriteText(wxString::Format(wxT("%i"), headerInfo.numHV));
		m_textCtrl1325->Clear();
		m_textCtrl1325->WriteText(headerInfo.linesHV);
		//m_textCtrl1323->WriteText(headerInfo.triggerHV);
		//m_textCtrl36->Clear();
		//m_textCtrl36->WriteText(wxString::Format(wxT("%f"), headerInfo.attenHV));
		setSourceConfig(headerInfo.sourceConfig);
}

void BigFrame::connectNIMClicked(wxCommandEvent& event){
	nim = new WeinerCounter(0);
	m_button19->Disable();
  m_button23->Enable();
}
void BigFrame::disconnectNIM(wxCommandEvent& event){
  delete nim;
  nim = nullptr;
  m_button19->Enable();
  m_button23->Disable();
}

bool camActive = false;
Camera* cam;// = new Camera();
void BigFrame::startCamera(wxCommandEvent& event)
{
  
    

  if (camActive == false)
  {
    cam = new Camera();
    //thread t3(&Camera::Camera, cam);
    //t3.detach();
    
    camActive = true;
    cam->startCamera();
  }
  else if (camActive == true)
  {
    cam->active = false;
    camActive = false;
    //delete cam;
  }
}

void BigFrame::stopSelected(wxCommandEvent& event){
	run = false;
  start->Enable();
  stop->Disable();
}

void BigFrame::startSelected(wxCommandEvent& event){
	
  
  fstream runfile;
	runfile.open("runfile.txt", std::fstream::in | std::fstream::out);
	char temp[200];
	runfile.getline(temp, 200);
	long int tempNum = atol(temp);
	globalHeader.runNumber = tempNum;
	tempNum++;
	runfile.seekg(0, ios::beg);
	runfile << tempNum;
	runfile.close();


	if (!volt){
		wxMessageBox("Voltage controller not connected");
	}
	else if (!nim){
		wxMessageBox("NIMBox not connected");
	}
	else if (!mot && !(scanType == "Free" || scanType == "Voltage_Scan")){
		wxMessageBox("X-Y controller not connected");
	}
	else if (!pglobalheader){
		wxMessageBox("Header information not found");
	}
  else if (!message){
		wxMessageBox("Please update run type information");
	}
	else if (!readout){
		wxMessageBox("Readout information not found");
	}
	else if (scanType == "Line_Scan" && !run){
		run = true;
    start->Disable();
		thread t1(doLineScan, mot, nim, volt, *message, *readout, *pglobalheader, &run);
		t1.detach();
	}
	else if (scanType == "Free" && !run){
		run = true;
    start->Disable();
    stop->Enable();
    message->voltage = message->voltageStart;
    thread t1(doWeinerCountInf, nim, "", *pglobalheader, *message, *readout, volt, &run);
		t1.detach();
	}
	else if (scanType == "Voltage_Scan" && !run){
		run = true;
    start->Disable();
    stop->Enable();
    thread t1(doVoltageScan, nim, *pglobalheader, volt, *message, *readout, &run);
    t1.detach();
	}
	else if (scanType == "Hex_Scan_X" && !run){
		run = true;
    start->Disable();
    stop->Enable();
		thread t1(doHexScanX, mot, nim, volt, *message, *readout, *pglobalheader, &run);
		t1.detach();
	}
	else if (scanType == "XY_Scan" && !run){
		run = true;
    start->Disable();
    stop->Enable();
    thread t1(doXYScan, mot, nim, volt, *message, *readout, *pglobalheader, &run);
		t1.detach();
	}

	//if (runArduino == true)
	//{
	//	thread t2(doArduino, *message, *pglobalheader, &run);
	//}
}

void BigFrame::openReadoutPane(wxCommandEvent& event){
  if (!readoutframe){
    readoutframe = new readoutedit(this);
  }
  readoutframe->update();
	readoutframe->Show(true);

}

readoutedit::readoutedit(wxWindow* parent) : MyFrame4(parent){

}

void readoutedit::okbuttonclicked(wxCommandEvent &event){
	while(!readout->active.empty())
	{
		readout->active.pop_back();
	}
	while (!readout->lines.empty())
	{
		readout->lines.pop_back();
	}

	if (m_checkBox77->IsChecked())
		readout->active.push_back(true);
	else
		readout->active.push_back(false);
	if (m_checkBox78->IsChecked())
		readout->active.push_back(true);
	else
		readout->active.push_back(false);
	if (m_checkBox79->IsChecked())
		readout->active.push_back(true);
	else
		readout->active.push_back(false);
	if (m_checkBox80->IsChecked())
		readout->active.push_back(true);
	else
		readout->active.push_back(false);
	if (m_checkBox81->IsChecked())
		readout->active.push_back(true);
	else
		readout->active.push_back(false);
	if (m_checkBox82->IsChecked())
		readout->active.push_back(true);
	else
		readout->active.push_back(false);
	if (m_checkBox83->IsChecked())
		readout->active.push_back(true);
	else
		readout->active.push_back(false);
	if (m_checkBox84->IsChecked())
		readout->active.push_back(true);
	else
		readout->active.push_back(false);
	if (m_checkBox85->IsChecked())
		readout->active.push_back(true);
	else
		readout->active.push_back(false);
	if (m_checkBox86->IsChecked())
		readout->active.push_back(true);
	else
		readout->active.push_back(false);
	if (m_checkBox771->IsChecked())
		readout->active.push_back(true);
	else
		readout->active.push_back(false);
	if (m_checkBox781->IsChecked())
		readout->active.push_back(true);
	else
		readout->active.push_back(false);
	if (m_checkBox791->IsChecked())
		readout->active.push_back(true);
	else
		readout->active.push_back(false);
	if (m_checkBox801->IsChecked())
		readout->active.push_back(true);
	else
		readout->active.push_back(false);
	if (m_checkBox811->IsChecked())
		readout->active.push_back(true);
	else
		readout->active.push_back(false);
	if (m_checkBox821->IsChecked())
		readout->active.push_back(true);
	else
		readout->active.push_back(false);
	if (m_checkBox831->IsChecked())
		readout->active.push_back(true);
	else
		readout->active.push_back(false);
	if (m_checkBox841->IsChecked())
		readout->active.push_back(true);
	else
		readout->active.push_back(false);
	if (m_checkBox851->IsChecked())
		readout->active.push_back(true);
	else
		readout->active.push_back(false);
	if (m_checkBox861->IsChecked())
		readout->active.push_back(true);
	else
		readout->active.push_back(false);

	int j = 1;

	readout->numActive = 0;
	for (int i = 0; i < 20; i++)
	{
		if (readout->active[i] == true)
		{
			readout->numActive++;
			readout->lines.push_back(i+1);
			//readout->lines[j] = i;
			j++;
		}
	}

	readoutframe->Show(false);
}

void readoutedit::update(){
  m_checkBox77->SetValue(readout->active[0]);
  m_checkBox78->SetValue(readout->active[1]);
  m_checkBox79->SetValue(readout->active[2]);
  m_checkBox80->SetValue(readout->active[3]);
  m_checkBox81->SetValue(readout->active[4]);
  m_checkBox82->SetValue(readout->active[5]);
  m_checkBox83->SetValue(readout->active[6]);
  m_checkBox84->SetValue(readout->active[7]);
  m_checkBox85->SetValue(readout->active[8]);
  m_checkBox86->SetValue(readout->active[9]);
  m_checkBox771->SetValue(readout->active[10]);
  m_checkBox781->SetValue(readout->active[11]);
  m_checkBox791->SetValue(readout->active[12]);
  m_checkBox801->SetValue(readout->active[13]);
  m_checkBox811->SetValue(readout->active[14]);
  m_checkBox821->SetValue(readout->active[15]);
  m_checkBox831->SetValue(readout->active[16]);
  m_checkBox841->SetValue(readout->active[17]);
  m_checkBox851->SetValue(readout->active[18]);
  m_checkBox861->SetValue(readout->active[19]);
}

void BigFrame::scanTypeFree()
{
  scanType = "Free";
  m_textCtrl18->Disable();
  //m_textCtrl18->SetValue(wxT("0"));
  m_textCtrl19->Disable();
  //m_textCtrl19->SetValue(wxT("0"));
  m_textCtrl20->Disable();
  //m_textCtrl20->SetValue(wxT("0"));
  m_textCtrl21->Disable();
  //m_textCtrl21->SetValue(wxT("0"));
  m_textCtrl41->Disable();
  //m_textCtrl41->SetValue(wxT("0"));
  m_textCtrl29->Disable();
  //m_textCtrl29->SetValue(wxT("0"));
  m_textCtrl22->Enable(); //start voltage
  m_textCtrl23->Disable();
  //m_textCtrl23->SetValue(wxT("0"));
  m_textCtrl40->Disable();
  //m_textCtrl40->SetValue(wxT("0"));
  m_textCtrl42->Disable();
  //m_textCtrl42->SetValue(wxT("0"));
  m_textCtrl43->Enable(); //nim interval time 
  m_textCtrl44->Disable();
  m_textCtrl451->Disable();
  m_textCtrl461->Disable();
  m_textCtrl47->Disable();
}

void BigFrame::scanTypeVoltage()
{
  scanType = "Voltage_Scan";
  m_textCtrl18->Disable();
  m_textCtrl19->Disable();
  m_textCtrl20->Disable();
  m_textCtrl21->Disable();
  m_textCtrl41->Disable();
  m_textCtrl29->Disable();
  m_textCtrl22->Enable(); //start voltage
  m_textCtrl23->Enable(); //end voltage
  m_textCtrl40->Enable(); //voltage step
  m_textCtrl42->Enable(); // measuremnt time
  m_textCtrl43->Enable();
}

void BigFrame::scanTypeLine()
{
  scanType = "Line_Scan";
  m_textCtrl18->Enable();
  m_textCtrl19->Enable();
  m_textCtrl20->Enable();
  m_textCtrl21->Enable();
  m_textCtrl41->Enable();
  m_textCtrl29->Enable();
  m_textCtrl22->Enable(); //start voltage
  m_textCtrl23->Enable();
  m_textCtrl40->Enable();
  m_textCtrl42->Enable();
  m_textCtrl43->Enable();
}

void BigFrame::scanTypeHex()
{
  scanType = "Hex_Scan_X";
  m_textCtrl18->Enable();
  m_textCtrl19->Enable();
  m_textCtrl20->Enable();
  m_textCtrl21->Enable();
  m_textCtrl41->Enable();
  m_textCtrl29->Enable();
  m_textCtrl22->Enable(); //start voltage
  m_textCtrl23->Enable();
  m_textCtrl40->Enable();
  m_textCtrl42->Enable();
  m_textCtrl43->Enable();
}

void BigFrame::scanTypeXY()
{
  scanType = "XY_Scan";
  m_textCtrl18->Enable();
  m_textCtrl19->Enable();
  m_textCtrl20->Enable();
  m_textCtrl21->Enable();
  m_textCtrl41->Enable();
  m_textCtrl29->Enable();
  m_textCtrl22->Enable(); //start voltage
  m_textCtrl23->Enable();
  m_textCtrl40->Enable();
  m_textCtrl42->Enable();
  m_textCtrl43->Enable();
  m_textCtrl44->Disable();
  m_textCtrl451->Disable();
  m_textCtrl461->Disable();
  m_textCtrl47->Disable();
}